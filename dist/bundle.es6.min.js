var _NumberisInteger=Number.isInteger,_Mathpow=Math.pow,_MathPI=Math.PI,_Mathtan=Math.tan,_Mathcos=Math.cos,_Mathsin=Math.sin,_Mathsqrt=Math.sqrt,_Mathmax=Math.max,_Mathabs=Math.abs;(function(n){function d(u){if(o[u])return o[u].exports;var l=o[u]={i:u,l:!1,exports:{}};return n[u].call(l.exports,l,l.exports,d),l.l=!0,l.exports}var o={};return d.m=n,d.c=o,d.i=function(u){return u},d.d=function(u,l,m){d.o(u,l)||Object.defineProperty(u,l,{configurable:!1,enumerable:!0,get:m})},d.n=function(u){var l=u&&u.__esModule?function(){return u['default']}:function(){return u};return d.d(l,'a',l),l},d.o=function(u,l){return Object.prototype.hasOwnProperty.call(u,l)},d.p='',d(d.s=18)})([function(n,d){'use strict';d.a=class{constructor(l,m,T,E=!1){this.label=l,this.type=m,this.data=T,this._init(m,E)}_init(l){switch(this.type){case 35676:{this.draw=(T,E)=>{T.uniformMatrix4fv(E,!1,this.data)};break}case 35665:{this.draw=(T,E)=>{T.uniform3f(E,...this.data)};break}case 5124:this.draw=(T,E)=>{T.uniform1i(E,this.data)};break;case-1:this.draw=(T,E)=>{T.uniform1fv(E,this.data)};break;default:console.error('Uniform type unknow: {label:',this.label,', type:',l,'}');}}}},function(n,d,o){'use strict';var u=o(6),l=o(5),m=o(0),T=o(17);class E extends u.a{constructor(_,I='aVertexPosition',R='uSample'){const D=new l.a;D.addVertices(I,[1,1,-1,1,-1,-1,-1,-1,1,-1,1,1],2),super(D,_)}resize(_,I){this.uWidth&&(this.uWidth.data=_),this.uHeight&&(this.uHeight.data=I)}useUWidth(_,I){const R=new m.a(_,5124,I);this.uWidth=R,this.addUniform(R)}useUHeight(_,I){const R=new m.a(_,5124,I);this.uHeight=R,this.addUniform(R)}useColorTexture(_){const I=new T.a(_);this.inColorTexture=I,this.addTexture(I)}useDepthTexture(_,I){const R=new T.a(_);this.inDepthTexture=R,this.addTexture(R);const D=new m.a(I,5124,1);this._inDetpthEnableUniform=D,this.addUniform(D)}setDepthTexture(_,I){this.rmTexture(this.inDepthTexture),_&&this.addTexture(this.inDepthTexture),this._inDetpthEnableUniform.data=_?1:0;const R=this.globalUniforms;this.dispose(),this.init(I,R)}}d.a=E},function(n,d){'use strict';const u=`      
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec4 vColor;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vColor = aVertexColor;
    }
`,l=`
    precision mediump float;

    varying vec4 vColor;

    void main(void) {
        gl_FragColor = vColor;
    }
`;let m=0;d.a=class{constructor(E=u,_=l){this.vertexShaderSrc=E,this.fragmentShaderSrc=_,this.attribLocation={},this.uniformLocation={},this.textureLocation={},this.textureIndex={},this.textureNum=0,this.id=++m}isInitialized(){return!!this.pointer}init(E){this.vertexShader=this._createShader(E,35633,this.vertexShaderSrc),this.fragmentShader=this._createShader(E,35632,this.fragmentShaderSrc);const _=E.createProgram();return(E.attachShader(_,this.vertexShader),E.attachShader(_,this.fragmentShader),E.linkProgram(_),!E.getProgramParameter(_,E.LINK_STATUS))?(console.error('Shader initialization error'),!1):(E.useProgram(_),this.pointer=_,!0)}getAttribLocation(E,_){const I=_.label;if(!this.attribLocation.hasOwnProperty(I)){const R=E.getAttribLocation(this.pointer,I);return E.enableVertexAttribArray(R),this.attribLocation[I]=R,R}return this.attribLocation[I]}getUniformLocation(E,_){const I=_.label;if(!this.uniformLocation.hasOwnProperty(I)){const R=E.getUniformLocation(this.pointer,I);return this.uniformLocation[I]=R,R}return this.uniformLocation[I]}getTextureLocationIndex(E,_){const I=_.label;if(!this.textureLocation.hasOwnProperty(I)||!this.textureIndex.hasOwnProperty(I)){const R=E.getUniformLocation(this.pointer,I);return this.textureLocation[I]=R,this.textureIndex[I]=this.textureNum,[R,this.textureNum++]}return[this.textureLocation[I],this.textureIndex[I]]}draw(E){E.useProgram(this.pointer)}_createShader(E,_,I){const R=E.createShader(_);return E.shaderSource(R,I),E.compileShader(R),E.getShaderParameter(R,E.COMPILE_STATUS)?R:console.error('Une erreur est survenue au cours de la compilation du shader: '+E.getShaderInfoLog(R))}}},function(n,d){'use strict';class u{constructor(){this.lastTexture=null,this.lastProgram=null}optimizeTexture(l){const m=this.lastTexture;return this.lastTexture=l,l===m}optimizeProgram(l){const m=this.lastProgram;return this.lastProgram=l,l===m}static getInstance(l){const m=u.glList.indexOf(l);if(0>m){const T=new u;return u.glList.push(l),u.list.push(T),T}return u.list[m]}}u.glList=[],u.list=[],d.a=u},function(n,d,o){'use strict';var u=o(7);class l extends u.a{constructor(m){super(),this.label=m}draw(m,T){super.draw(m),m.vertexAttribPointer(T,this.itemSize,this.itemType,!1,0,0)}copy(m=new l(this.label)){return m.label=this.label,super.copy(m),m}}d.a=l},function(n,d,o){'use strict';var u=o(7),l=o(4);d.a=class{constructor(){this.attributes=[],this.buffers=[],this.hasIndices=!1,this.numItems=0}addVertices(T,E,_){const I=new l.a(T);I.setArray(new Float32Array(E),34962),I.setItems(5126,_),this.attributes.push(I),1>this.numItems&&(this.numItems=E.length/_)}addIndices(T){this.hasIndices=!0;const E=new u.a;E.setArray(new Uint16Array(T),34963),E.setItems(5125,1),this.buffers.push(E),this.numItems=T.length}display(T){this.hasIndices?T.drawElements(T.TRIANGLES,this.numItems,T.UNSIGNED_SHORT,0):T.drawArrays(T.TRIANGLES,0,this.numItems)}}},function(n,d,o){'use strict';var u=o(3);d.a=class{constructor(m,T){this.geom=m,this.program=T,this.uniforms=[],this.globalUniforms=[],this.textures=[],this.localCalls=[],this.globalCalls=[],this.order=0,this._isInitialized=!1}addUniform(m){this.uniforms.push(m)}rmUniform(m){const T=this.uniforms.indexOf(m);-1<T&&this.uniforms.splice(T,1)}addTexture(m){this.textures.push(m)}rmTexture(m){const T=this.textures.indexOf(m);-1<T&&this.textures.splice(T,1)}isInitialized(){let m=this._isInitialized;if(m)return m;this.program.isInitialized()||(m=!1);for(const T of this.geom.attributes)T.isInitialized()||(m=!1);for(const T of this.geom.buffers)T.isInitialized()||(m=!1);for(const T of this.textures)T.isInitialized()||(m=!1);return m}_setCalls(m,T){const E=this.program;for(const _ of this.geom.attributes){const I=E.getAttribLocation(m,_);this.localCalls.push(_.draw.bind(_,m,I))}for(const _ of this.geom.buffers)this.localCalls.push(_.draw.bind(_,m));for(const _ of this.uniforms){const I=E.getUniformLocation(m,_);this.localCalls.push(_.draw.bind(_,m,I))}for(const _ of this.textures){const[I,R]=E.getTextureLocationIndex(m,_);this.localCalls.push(_.draw.bind(_,m,I,R))}for(const _ of T){const I=E.getUniformLocation(m,_);this.globalCalls.push(_.draw.bind(_,m,I))}}_initData(m){this.program;let E=!0;for(const _ of this.geom.attributes)_.isInitialized()||_.init(m)||(E=!1);for(const _ of this.geom.buffers)_.isInitialized()||_.init(m)||(E=!1);for(const _ of this.textures)_.isInitialized()||_.init(m)||(E=!1);return E}dispose(){this._isInitialized=!1,this.localCalls.length=0}init(m,T){this.program;let _=!0;return this.program.isInitialized()?this.program.draw(m):!this.program.init(m)&&(_=!1),this._initData(m)||(_=!1),_&&1>this.localCalls.length&&this._setCalls(m,T),this.globalUniforms=[...T],this._isInitialized=_,_}draw(m,T=[]){const E=u.a.getInstance(m),_=this.program,I=E.optimizeProgram(_);if(!I){this.program.draw(m);for(const R of this.globalCalls)R()}for(const R of this.localCalls)R();for(const R of T)R();this.geom.display(m)}}},function(n,d){'use strict';class u{constructor(){this.pointer=null,this.gl=null,this.arrayType=34962,this.data=null,this.arrayUsage=35044}isInitialized(){return!!this.pointer}setArray(l,m=this.arrayType,T=this.arrayUsage){this.arrayType=m,this.data=l,this.arrayUsage=T;const E=this.gl;E&&(E.bindBuffer(m,this.pointer),E.bufferData(m,l,arrayUsage))}setItems(l=5126,m=3,T=null){this.itemType=l,this.itemSize=m}init(l){const m=l.createBuffer();return l.bindBuffer(this.arrayType,m),l.bufferData(this.arrayType,this.data,this.arrayUsage),this.pointer=m,this.gl=l,!0}draw(l){l.bindBuffer(this.arrayType,this.pointer)}copy(l=new u){return l.setArray(this.data,this.arrayType,this.arrayUsage),l.setItems(this.itemType,this.itemSize),l}}d.a=u},function(n,d,o){'use strict';var u=o(3);class l{constructor(m){this.label=m,this.mipmap=!0,this.img=null,this.width=null,this.height=null,this.pointer=null,this.parameters=[],this.setType(),this.setInternalFormat(),this.setFormat(),this.setTarget()}resize(m,T,E=null){this.width=m,this.height=T,E?(E.bindTexture(this.target,this.pointer),E.texImage2D(this.target,0,this.internalFormat,this.width,this.height,0,this.format,this.type,this.img)):this.updated=!0}setTempColor(m){this.setImg(new Uint8Array(m),1,1)}setImg(m=new Uint8Array([255,255,255,255]),T=1,E=1){this.img=m,this.width=T,this.height=E}setType(m=5121){this.type=m}setInternalFormat(m=6408){this.internalFormat=m}setFormat(m=6408){this.format=m}setTarget(m=3553){this.target=m}setParam(m,T){const E=this.parameters.find((_)=>_[0]===m);-1<E?this.parameters[E][1]=T:this.parameters.push([m,T])}isInitialized(){return!!this.pointer}static IS_POWER_OF_2(m){return 0==(m&m-1)}static SET_DATA(m){l.MAX_SIZE=m.getParameter(m.MAX_TEXTURE_SIZE),l.FORMAT={};const T=m.getParameter(m.COMPRESSED_TEXTURE_FORMATS);for(let E=0;E<T.length;E++)l.FORMAT[T[E]]=!0;l._DATA_INITIALIZED=!0}setDefaultParams(m){this.mipmap?this.setParam(m.TEXTURE_MIN_FILTER,m.LINEAR_MIPMAP_LINEAR):(this.setParam(m.TEXTURE_WRAP_S,m.CLAMP_TO_EDGE),this.setParam(m.TEXTURE_WRAP_T,m.CLAMP_TO_EDGE),this.setParam(m.TEXTURE_MIN_FILTER,m.LINEAR))}initParams(m){if(this.mipmap){const T=this.img;null===T?console.warn('You need an image to set the parameters of texture'):l.IS_POWER_OF_2(T.width)&&l.IS_POWER_OF_2(T.height)?m.generateMipmap(this.target):(this.mipmap=!1,console.warn('You need a power of 2 for the size of the mipmaped texture'))}1>this.parameters.length&&this.setDefaultParams(m);for(const[T,E]of this.parameters)m.texParameteri(this.target,T,E)}init(m){const T=m.createTexture();return l._DATA_INITIALIZED||l.SET_DATA(m),m.bindTexture(this.target,T),m.texImage2D(this.target,0,this.internalFormat,this.width,this.height,0,this.format,this.type,this.img),this.initParams(m),this.pointer=T,!0}draw(m,T,E){const _=u.a.getInstance(m),I=_.optimizeTexture(this);I||(m.uniform1i(T,E),m.activeTexture(m.TEXTURE0+E),m.bindTexture(this.target,this.pointer),this.updated&&(m.texImage2D(this.target,0,this.internalFormat,this.width,this.height,0,this.format,this.type,this.img),this.updated=!1))}free(m){m.bindTexture(m.TEXTURE_2D,null)}}d.a=l},function(n,d){'use strict';function u(T,E,_,I,R,D,P,F,A,U,L,C,B,M,N,O,v){T[0]=E,T[1]=_,T[2]=I,T[3]=R,T[4]=D,T[5]=P,T[6]=F,T[7]=A,T[8]=U,T[9]=L,T[10]=C,T[11]=B,T[12]=M,T[13]=N,T[14]=O,T[15]=v}const l=1e-6;class m extends Float32Array{constructor(){super(16),this[0]=1,this[5]=1,this[10]=1,this[15]=1}clone(){const T=new m;return T.set(this),T}copy(T){return T.set(this),this}identity(){return u(this,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}add(T){return this[0]+=T[0],this[1]+=T[1],this[2]+=T[2],this[3]+=T[3],this[4]+=T[4],this[5]+=T[5],this[6]+=T[6],this[7]+=T[7],this[8]+=T[8],this[9]+=T[9],this[10]+=T[10],this[11]+=T[11],this[12]+=T[12],this[13]+=T[13],this[14]+=T[14],this[15]+=T[15],this}subtract(T){return this[0]-=T[0],this[1]-=T[1],this[2]-=T[2],this[3]-=T[3],this[4]-=T[4],this[5]-=T[5],this[6]-=T[6],this[7]-=T[7],this[8]-=T[8],this[9]-=T[9],this[10]-=T[10],this[11]-=T[11],this[12]-=T[12],this[13]-=T[13],this[14]-=T[14],this[15]-=T[15],this}multiplyScalar(T){return this[0]*=T,this[1]*=T,this[2]*=T,this[3]*=T,this[4]*=T,this[5]*=T,this[6]*=T,this[7]*=T,this[8]*=T,this[9]*=T,this[10]*=T,this[11]*=T,this[12]*=T,this[13]*=T,this[14]*=T,this[15]*=T,this}multiplyScalarAndAdd(T,E){return this[0]+=T[0]*E,this[1]+=T[1]*E,this[2]+=T[2]*E,this[3]+=T[3]*E,this[4]+=T[4]*E,this[5]+=T[5]*E,this[6]+=T[6]*E,this[7]+=T[7]*E,this[8]+=T[8]*E,this[9]+=T[9]*E,this[10]+=T[10]*E,this[11]+=T[11]*E,this[12]+=T[12]*E,this[13]+=T[13]*E,this[14]+=T[14]*E,this[15]+=T[15]*E,this}exactEquals(T){return this[0]===T[0]&&this[1]===T[1]&&this[2]===T[2]&&this[3]===T[3]&&this[4]===T[4]&&this[5]===T[5]&&this[6]===T[6]&&this[7]===T[7]&&this[8]===T[8]&&this[9]===T[9]&&this[10]===T[10]&&this[11]===T[11]&&this[12]===T[12]&&this[13]===T[13]&&this[14]===T[14]&&this[15]===T[15]}equals(T){const[E,_,I,R,D,P,F,A,U,L,C,B,M,N,O,v]=this,[V,H,W,X,G,q,Z,k,K,Y,$,Q,J,ee,te,re]=T;return _Mathabs(E-V)<=l*_Mathmax(1,_Mathabs(E),_Mathabs(V))&&_Mathabs(_-H)<=l*_Mathmax(1,_Mathabs(_),_Mathabs(H))&&_Mathabs(I-W)<=l*_Mathmax(1,_Mathabs(I),_Mathabs(W))&&_Mathabs(R-X)<=l*_Mathmax(1,_Mathabs(R),_Mathabs(X))&&_Mathabs(D-G)<=l*_Mathmax(1,_Mathabs(D),_Mathabs(G))&&_Mathabs(P-q)<=l*_Mathmax(1,_Mathabs(P),_Mathabs(q))&&_Mathabs(F-Z)<=l*_Mathmax(1,_Mathabs(F),_Mathabs(Z))&&_Mathabs(A-k)<=l*_Mathmax(1,_Mathabs(A),_Mathabs(k))&&_Mathabs(U-K)<=l*_Mathmax(1,_Mathabs(U),_Mathabs(K))&&_Mathabs(L-Y)<=l*_Mathmax(1,_Mathabs(L),_Mathabs(Y))&&_Mathabs(C-$)<=l*_Mathmax(1,_Mathabs(C),_Mathabs($))&&_Mathabs(B-Q)<=l*_Mathmax(1,_Mathabs(B),_Mathabs(Q))&&_Mathabs(M-J)<=l*_Mathmax(1,_Mathabs(M),_Mathabs(J))&&_Mathabs(N-ee)<=l*_Mathmax(1,_Mathabs(N),_Mathabs(ee))&&_Mathabs(O-te)<=l*_Mathmax(1,_Mathabs(O),_Mathabs(te))&&_Mathabs(v-re)<=l*_Mathmax(1,_Mathabs(v),_Mathabs(re))}transpose(T){if(T===this){const E=T[1],_=T[2],I=T[3],R=T[6],D=T[7],P=T[11];this[1]=T[4],this[2]=T[8],this[3]=T[12],this[4]=E,this[6]=T[9],this[7]=T[13],this[8]=_,this[9]=R,this[11]=T[14],this[12]=I,this[13]=D,this[14]=P}else u(this,T[0],T[4],T[8],T[12],T[1],T[5],T[9],T[13],T[2],T[6],T[10],T[14],T[3],T[7],T[11],T[15]);return this}invert(){const[T,E,_,I,R,D,P,F,A,U,L,C,B,M,N,O]=this,v=T*D-E*R,V=T*P-_*R,H=T*F-I*R,W=E*P-_*D,X=E*F-I*D,G=_*F-I*P,q=A*M-U*B,Z=A*N-L*B,k=A*O-C*B,K=U*N-L*M,Y=U*O-C*M,$=L*O-C*N;let Q=v*$-V*Y+H*K+W*k-X*Z+G*q;return Q?(Q=1/Q,u(this,(D*$-P*Y+F*K)*Q,(_*Y-E*$-I*K)*Q,(M*G-N*X+O*W)*Q,(L*X-U*G-C*W)*Q,(P*k-R*$-F*Z)*Q,(T*$-_*k+I*Z)*Q,(N*H-B*G-O*V)*Q,(A*G-L*H+C*V)*Q,(R*Y-D*k+F*q)*Q,(E*k-T*Y-I*q)*Q,(B*X-M*H+O*v)*Q,(U*H-A*X-C*v)*Q,(D*Z-R*K-P*q)*Q,(T*K-E*Z+_*q)*Q,(M*V-B*W-N*v)*Q,(A*W-U*V+L*v)*Q),this):this}adjoint(){const[T,E,_,I,R,D,P,F,A,U,L,C,B,M,N,O]=this;return u(this,D*(L*O-C*N)-U*(P*O-F*N)+M*(P*C-F*L),-(E*(L*O-C*N)-U*(_*O-I*N)+M*(_*C-I*L)),E*(P*O-F*N)-D*(_*O-I*N)+M*(_*F-I*P),-(E*(P*C-F*L)-D*(_*C-I*L)+U*(_*F-I*P)),-(R*(L*O-C*N)-A*(P*O-F*N)+B*(P*C-F*L)),T*(L*O-C*N)-A*(_*O-I*N)+B*(_*C-I*L),-(T*(P*O-F*N)-R*(_*O-I*N)+B*(_*F-I*P)),T*(P*C-F*L)-R*(_*C-I*L)+A*(_*F-I*P),R*(U*O-C*M)-A*(D*O-F*M)+B*(D*C-F*U),-(T*(U*O-C*M)-A*(E*O-I*M)+B*(E*C-I*U)),T*(D*O-F*M)-R*(E*O-I*M)+B*(E*F-I*D),-(T*(D*C-F*U)-R*(E*C-I*U)+A*(E*F-I*D)),-(R*(U*N-L*M)-A*(D*N-P*M)+B*(D*L-P*U)),T*(U*N-L*M)-A*(E*N-_*M)+B*(E*L-_*U),-(T*(D*N-P*M)-R*(E*N-_*M)+B*(E*P-_*D)),T*(D*L-P*U)-R*(E*L-_*U)+A*(E*P-_*D)),this}determinant(){const[T,E,_,I,R,D,P,F,A,U,L,C,B,M,N,O]=this;return(T*D-E*R)*(L*O-C*N)-(T*P-_*R)*(U*O-C*M)+(T*F-I*R)*(U*N-L*M)+(E*P-_*D)*(A*O-C*B)-(E*F-I*D)*(A*N-L*B)+(_*F-I*P)*(A*M-U*B)}multiply(T){const[E,_,I,R,D,P,F,A,U,L,C,B,M,N,O,v]=this;let[V,H,W,X]=T;return this[0]=V*E+H*D+W*U+X*M,this[1]=V*_+H*P+W*L+X*N,this[2]=V*I+H*F+W*C+X*O,this[3]=V*R+H*A+W*B+X*v,V=T[4],H=T[5],W=T[6],X=T[7],this[4]=V*E+H*D+W*U+X*M,this[5]=V*_+H*P+W*L+X*N,this[6]=V*I+H*F+W*C+X*O,this[7]=V*R+H*A+W*B+X*v,V=T[8],H=T[9],W=T[10],X=T[11],this[8]=V*E+H*D+W*U+X*M,this[9]=V*_+H*P+W*L+X*N,this[10]=V*I+H*F+W*C+X*O,this[11]=V*R+H*A+W*B+X*v,V=T[12],H=T[13],W=T[14],X=T[15],this[12]=V*E+H*D+W*U+X*M,this[13]=V*_+H*P+W*L+X*N,this[14]=V*I+H*F+W*C+X*O,this[15]=V*R+H*A+W*B+X*v,this}translate([T,E,_]){return this[12]=this[0]*T+this[4]*E+this[8]*_+this[12],this[13]=this[1]*T+this[5]*E+this[9]*_+this[13],this[14]=this[2]*T+this[6]*E+this[10]*_+this[14],this[15]=this[3]*T+this[7]*E+this[11]*_+this[15],this}scale([T,E,_]){return this[0]*=T,this[1]*=T,this[2]*=T,this[3]*=T,this[4]*=E,this[5]*=E,this[6]*=E,this[7]*=E,this[8]*=_,this[9]*=_,this[10]*=_,this[11]*=_,this}rotate(T,[E,_,I]){let R=_Mathsqrt(E*E+_*_+I*I);if(_Mathabs(R)>l){R=1/R,E*=R,_*=R,I*=R;const D=_Mathsin(T),P=_Mathcos(T),F=1-P,[A,U,L,C,B,M,N,O,v,V,H,W]=this,X=E*E*F+P,G=_*E*F+I*D,q=I*E*F-_*D,Z=E*_*F-I*D,k=_*_*F+P,K=I*_*F+E*D,Y=E*I*F+_*D,$=_*I*F-E*D,Q=I*I*F+P;this[0]=A*X+B*G+v*q,this[1]=U*X+M*G+V*q,this[2]=L*X+N*G+H*q,this[3]=C*X+O*G+W*q,this[4]=A*Z+B*k+v*K,this[5]=U*Z+M*k+V*K,this[6]=L*Z+N*k+H*K,this[7]=C*Z+O*k+W*K,this[8]=A*Y+B*$+v*Q,this[9]=U*Y+M*$+V*Q,this[10]=L*Y+N*$+H*Q,this[11]=C*Y+O*$+W*Q}return this}rotateX(T){const E=_Mathsin(T),_=_Mathcos(T),I=this[4],R=this[5],D=this[6],P=this[7],F=this[8],A=this[9],U=this[10],L=this[11];return this[4]=I*_+F*E,this[5]=R*_+A*E,this[6]=D*_+U*E,this[7]=P*_+L*E,this[8]=F*_-I*E,this[9]=A*_-R*E,this[10]=U*_-D*E,this[11]=L*_-P*E,this}rotateY(T){const E=_Mathsin(T),_=_Mathcos(T),I=a[0],R=a[1],D=a[2],P=a[3],F=a[8],A=a[9],U=a[10],L=a[11];return this[0]=I*_-F*E,this[1]=R*_-A*E,this[2]=D*_-U*E,this[3]=P*_-L*E,this[8]=I*E+F*_,this[9]=R*E+A*_,this[10]=D*E+U*_,this[11]=P*E+L*_,this}rotateZ(T){const E=_Mathsin(T),_=_Mathcos(T),[I,R,D,P,F,A,U,L]=this;return this[0]=I*_+F*E,this[1]=R*_+A*E,this[2]=a02*_+U*E,this[3]=P*_+L*E,this[4]=F*_-I*E,this[5]=A*_-R*E,this[6]=U*_-a02*E,this[7]=L*_-P*E,this}fromTranslation(T){return u(this,1,0,0,0,0,1,0,0,0,0,1,0,T[0],T[1],T[2],1),this}fromScaling(T){return u(this,T[0],0,0,0,0,T[1],0,0,0,0,T[2],0,0,0,0,1),this}fromRotation(T,[E,_,I]){let R=_Mathsqrt(E*E+_*_+I*I);if(_Mathabs(R)>l){R=1/R,E*=R,_*=R,I*=R;const D=_Mathsin(T),P=_Mathcos(T),F=1-P;u(this,E*E*F+P,_*E*F+I*D,I*E*F-_*D,0,E*_*F-I*D,_*_*F+P,I*_*F+E*D,0,E*I*F+_*D,_*I*F-E*D,I*I*F+P,0,0,0,0,1)}return this}fromXRotation(T){const E=_Mathsin(T),_=_Mathcos(T);return u(this,1,0,0,0,0,_,E,0,0,-E,_,0,0,0,0,1),this}fromYRotation(T){const E=_Mathsin(T),_=_Mathcos(T);return u(this,_,0,-E,0,0,1,0,0,E,0,_,0,0,0,0,1),this}fromZRotation(T){const E=_Mathsin(T),_=_Mathcos(T);return u(this,_,E,0,0,-E,_,0,0,0,0,1,0,0,0,0,1),this}fromQuat(T){const[E,_,I,R]=T,D=E+E,P=_+_,F=I+I,A=E*D,U=_*D,L=_*P,C=I*D,B=I*P,M=I*F,N=R*D,O=R*P,v=R*F;return u(this,1-L-M,U+v,C-O,0,U-v,1-A-M,B+N,0,C+O,B-N,1-A-L,0,0,0,0,1),this}fromRotationTranslation(T,E){const[_,I,R,D]=T,P=_+_,F=I+I,A=R+R,U=_*P,L=_*F,C=_*A,B=I*F,M=I*A,N=R*A,O=D*P,v=D*F,V=D*A;return u(this,1-(B+N),L+V,C-v,0,L-V,1-(U+N),M+O,0,C+v,M-O,1-(U+B),0,E[0],E[1],E[2],1),this}fromRotationTranslationScale(T,E,[_,I,R]){const[D,P,F,A]=T,U=D+D,L=P+P,C=F+F,B=D*U,M=D*L,N=D*C,O=P*L,v=P*C,V=F*C,H=A*U,W=A*L,X=A*C;return u(this,(1-(O+V))*_,(M+X)*_,(N-W)*_,0,(M-X)*I,(1-(B+V))*I,(v+H)*I,0,(N+W)*R,(v-H)*R,(1-(B+O))*R,0,E[0],E[1],E[2],1),this}fromRotationTranslationScaleOrigin(T,E,_,I){const[R,D,P,F]=T,A=R+R,U=D+D,L=P+P,C=R*A,B=R*U,M=R*L,N=D*U,O=D*L,v=P*L,V=F*A,H=F*U,W=F*L,[X,G,q]=_,[Z,k,K]=I;return u(this,(1-(N+v))*X,(B+W)*X,(M-H)*X,0,(B-W)*G,(1-(C+v))*G,(O+V)*G,0,(M+H)*q,(O-V)*q,(1-(C+N))*q,0,E[0]+Z-(this[0]*Z+this[4]*k+this[8]*K),E[1]+k-(this[1]*Z+this[5]*k+this[9]*K),E[2]+K-(this[2]*Z+this[6]*k+this[10]*K),1),this}getTranslation(T,E=new Float32Array(3)){return E[0]=this[12],E[1]=this[13],E[2]=this[14],E}getRotation(T=new Float32Array(4)){var E=this[0]+this[5]+this[10];if(0<E){const _=2*_Mathsqrt(E+1);T[0]=(this[6]-this[9])/_,T[1]=(this[8]-this[2])/_,T[2]=(this[1]-this[4])/_,T[3]=0.25*_}else if(this[0]>this[5]&this[0]>this[10]){const _=2*_Mathsqrt(1+this[0]-this[5]-this[10]);T[0]=0.25*_,T[1]=(this[1]+this[4])/_,T[2]=(this[8]+this[2])/_,T[3]=(this[6]-this[9])/_}else if(this[5]>this[10]){const _=_Mathsqrt(1+this[5]-this[0]-this[10]);T[0]=2*((this[1]+this[4])/_),T[1]=0.25*_,T[2]=(this[6]+this[9])/_,T[3]=(this[8]-this[2])/_}else{const _=2*_Mathsqrt(1+this[10]-this[0]-this[5]);T[0]=(this[8]+this[2])/_,T[1]=(this[6]+this[9])/_,T[2]=0.25*_,T[3]=(this[1]-this[4])/_}return T}frustrum(T,E,_,I,R,D){const P=1/(E-T),F=1/(I-_),A=1/(R-D);return u(this,2*R*P,0,0,0,0,2*R*F,0,0,(E+T)*P,(I+_)*F,(D+R)*A,-1,0,0,2*(D*R)*A,0),this}perspective(T,E,_,I){const R=1/_Mathtan(T/2),D=1/(_-I);return u(this,R/E,0,0,0,0,R,0,0,0,0,(I+_)*D,-1,0,0,2*I*_*D,0),this}perspectiveFromFieldOfView(T,E,_){const I=_Mathtan(T.upDegrees*_MathPI/180),R=_Mathtan(T.downDegrees*_MathPI/180),D=_Mathtan(T.leftDegrees*_MathPI/180),P=_Mathtan(T.rightDegrees*_MathPI/180),F=2/(D+P),A=2/(I+R);return u(this,F,0,0,0,0,A,0,0,0.5*(-(D-P)*F),0.5*((I-R)*A),_/(E-_),-1,0,0,_*E/(E-_),0),this}ortho(T,E,_,I,R,D){const P=1/(T-E),F=1/(_-I),A=1/(R-D);return u(this,-2*P,0,0,0,0,-2*F,0,0,0,0,2*A,0,(T+E)*P,(I+_)*F,(D+R)*A,1),this}lookAt(T,E,_){const[I,R,D]=T,[P,F,A]=_,[U,L,C]=E;if(_Mathabs(I-U)<l&&_Mathabs(R-L)<l&&_Mathabs(D-C)<l)return this.identity();let B=I-U,M=R-L,N=D-C,O=1/_Mathsqrt(B*B+M*M+N*N);B*=O,M*=O,N*=O;let v=F*N-A*M,V=A*B-P*N,H=P*M-F*B;O=_Mathsqrt(v*v+V*V+H*H),O?(O=1/O,v*=O,V*=O,H*=O):(v=0,V=0,H=0);let W=M*H-N*V,X=N*v-B*H,G=B*V-M*v;return O=_Mathsqrt(W*W+X*X+G*G),O?(O=1/O,W*=O,X*=O,G*=O):(W=0,X=0,G=0),u(this,v,W,B,0,V,X,M,0,H,G,N,0,-(v*I+V*R+H*D),-(W*I+X*R+G*D),-(B*I+M*R+N*D),1),this}frob(){return _Mathsqrt(_Mathpow(this[0],2)+_Mathpow(this[1],2)+_Mathpow(this[2],2)+_Mathpow(this[3],2)+_Mathpow(this[4],2)+_Mathpow(this[5],2)+_Mathpow(this[6],2)+_Mathpow(this[7],2)+_Mathpow(this[8],2)+_Mathpow(this[9],2)+_Mathpow(this[10],2)+_Mathpow(this[11],2)+_Mathpow(this[12],2)+_Mathpow(this[13],2)+_Mathpow(this[14],2)+_Mathpow(this[15],2))}}d.a=m},function(n,d,o){'use strict';var u=o(9),l=o(0);class m extends l.a{constructor(T){super(T,35676,new u.a),this.fovy=45,this.near=0.1,this.far=1e3,this._matrix=new u.a,this.updated=!0}get matrix(){return this.updated=!0,this._matrix}update(T,E){this.data.perspective(this.fovy*_MathPI/180,T/E,0.1,100),this.data.multiply(this._matrix),this.updated=!1}}d.a=m},function(n,d,o){'use strict';o(3);class l{constructor(m,T){this.canvas=m,this.init(m),this.meshs=[],this.cam=T,this.uniforms=[T],this.depthTest=!0,this.sortCompare=(E,_)=>{return E.program.id-_.program.id},this.resize(m.width,m.height)}_addCamToMeshs(){const m=this.cam;this.uniforms.push(m)}addMesh(m){this.meshs.push(m),m.isInitialized()||m.init(this.gl,this.uniforms)}rmMesh(m){const T=this.meshs.indexOf(m);-1<T&&this.meshs.splice(T,1)}sort(){this.meshs.sort(this.sortCompare)}resize(m,T){this.width=m,this.height=T}init(m){let T;try{T=m.getContext('webgl')||m.getContext('experimental-webgl')}catch(E){console.error('Could not initialise WebGL:',E.message)}T||console.error('Could not initialise WebGL'),this.gl=T}set depthTest(m){const T=this.gl;!m?T.disable(T.DEPTH_TEST):T.enable(T.DEPTH_TEST),this._depthTest=!!m}get depthTest(){return this._depthTest}set bgColor([m,T,E,_=1]){this.gl.clearColor(m,T,E,_),this._bgColor=[m,T,E,_]}get bgColor(){return this._bgColor}draw(){const m=this.gl;m.viewport(0,0,this.width,this.height),m.clear(m.COLOR_BUFFER_BIT|m.DEPTH_BUFFER_BIT),this.cam.updated&&this.cam.update(this.width,this.height);for(const T of this.meshs)T.isInitialized()?T.draw(m):T.init(m,this.uniforms)}}d.a=l},function(n,d,o){'use strict';var l=o(8);class m extends l.a{constructor(T){super(T),this.srcs=[],this.setTempColor([255,255,255,255])}setTempColor(T){this.setImg(new Uint8Array(T),1,1)}addURL(T,E=0){const _={size:E,src:T,img:null,priority:0,isImage:!0,isValid:()=>!0,init:null};_.init=(I)=>{I.bindTexture(I.TEXTURE_2D,this.pointer),I.pixelStorei(I.UNPACK_FLIP_Y_WEBGL,!0),I.texImage2D(I.TEXTURE_2D,0,6408,this.format,I.UNSIGNED_BYTE,_.img),this.img=_.img,this.initParams(I)},this.srcs.push(_)}static START_LOAD(T,E){if(0<E.length){E.sort((I,R)=>I.size===R.size?I.size-R.size:I.priority-R.priority);E.filter((I)=>I.size>=l.a.MAX_SIZE&&I.isValid(T));if(1<E.length){const I=E[0],R=E[E.length-1];m.LOAD(I,()=>{I.init(T),m.LOAD(R,()=>{R.init(T)})})}else if(0<E.length){const I=E[0];m.LOAD(I,()=>{I.init(T)})}else console.warn('The GPU can\'nt load a texture with size > ',l.a.MAX_SIZE)}else console.warn('URL of your smart texture not found')}static LOAD(T,E){if(T.isImage){const _=new Image;_.onload=()=>{E(T)},T.img=_,_.src=T.src}else{const _=new XMLHttpRequest;_.responseType='arraybuffer',_.open('GET',T.src,!0),_.onreadystatechange=()=>{_.readyState===XMLHttpRequest.DONE&&(200===_.status?(T.img=_.response,E(T)):console.error('fail to load image ',T.src,'status:',_.status,'statuc text:',_.statusText))},_.send()}}init(T,E){const _=super.init(T,E),I=this.pointer;return m.START_LOAD(T,this.srcs),_}}d.a=m},function(n,d,o){'use strict';var u=o(9),l=o(0);class m extends l.a{constructor(T){super(T,35676,new u.a().identity())}}d.a=m},function(n,d,o){'use strict';var u=o(21);d.a=class{constructor(m){this.screenRecorder=new u.a(m.width,m.height,!0,!0),this.scene=m,this.passList=[],this.isEnable=!1,this.init(m.gl)}isInitialized(){return this.screenRecorder.isInitialized()}resize(m,T){this.scene.resize(m,T),this.screenRecorder.resize(m,T);for(const E of this.passList)E.resize(m,T)}_disableDepthInTexture(m,T){m.inDepthTexture&&m.setDepthTexture(!1,T)}init(m){if(this.screenRecorder.init(m),!this.screenRecorder.depthTexture)for(const T of this.passList)this._disableDepthInTexture(T,m);return!0}addPass(m){m.init(this.scene.gl,[]),this.screenRecorder.isInitialized()&&!this.screenRecorder.depthTexture&&this._disableDepthInTexture(m,this.scene.gl),m.uWidth&&(m.uWidth.data=this.scene.width),m.uHeight&&(m.uHeight.data=this.scene.height),this.passList.push(m),this.isEnable=!0}removePass(m){const T=this.passList.indexOf(m);-1<T&&this.passList.splice(T,1),this.isEnable=0<this.passList.length}draw(){const m=this.scene.gl,T=this.passList.length;if(0<T){this.screenRecorder.start(m,!0),this.scene.draw(),this.screenRecorder.stop(m),this.screenRecorder.pingpong();for(let E=0;E<T;E++){const _=this.passList[E],I=E>T-2;I||this.screenRecorder.start(m,!1),this.screenRecorder.pingpong(),_.inColorTexture&&_.inColorTexture.setTexture(this.screenRecorder.colorTexture),_.inDepthTexture&&this.screenRecorder.depthTexture&&_.inDepthTexture.setTexture(this.screenRecorder.depthTexture),_.draw(m),this.screenRecorder.stop(m)}}else this.scene.draw()}}},function(n,d,o){'use strict';function u(R){return _NumberisInteger(R)?R.toFixed(1):R}var l=o(1),m=o(2),T=o(0);const E=`
    attribute vec3 aVertexPosition;
    varying vec2 vTextureCoord;

    void main(void)
    {
        vTextureCoord = vec2(aVertexPosition.x * 0.5 + 0.5, aVertexPosition.y * 0.5 + 0.5);
        gl_Position = vec4(aVertexPosition, 1.0);
    }`,_=`
    precision mediump float;
    varying vec2 vTextureCoord;
    uniform sampler2D uColor;
    uniform sampler2D uDepth;

    uniform vec3 uColorFog;
    
    uniform int uDepthEnable;

    void main(void)
    {
        $chunkcall
        gl_FragColor = color;
    }`;class I extends l.a{constructor({minDepth:R=0.1,maxDepth:D=0.2,minPower:P=0.2,maxPower:F=1,depthCurve:A=100,color:U=[1,1,1]}){super(null,'aVertexPosition','uColor'),this.useColorTexture('uColor'),this.useDepthTexture('uDepth','uDepthEnable');const L=new T.a('uColorFog',35665,U);this.addUniform(L);const C=this._initFragmentShader(R,D,P,F,A);this.program=new m.a(E,C)}_initFragmentShader(R,D,P,F,A){let U=`
            float depthValue = 0.0;
            if (uDepthEnable >= 0) {
                vec4 depth = texture2D(uDepth, vTextureCoord.xy);
                depthValue = pow(depth.x, ${u(A)});
                depthValue = (depthValue - ${u(R)}) / ${u(D-R)};
                depthValue = clamp(depthValue, ${u(P)}, ${u(F)});
            }
            vec4 originalColor = texture2D(uColor, vTextureCoord.xy); 
            vec4 color = vec4(mix(originalColor.xyz, uColorFog, depthValue), originalColor.w);
        `;const L=_.replace('$chunkcall',U);return L}}d.a=I},function(n,d,o){'use strict';function u(R){return _NumberisInteger(R)?R.toFixed(1):R}var l=o(1),m=o(2),T=o(0);const E=`
    attribute vec3 aVertexPosition;
    varying vec2 vTextureCoord;

    void main(void)
    {
        vTextureCoord = vec2(aVertexPosition.x * 0.5 + 0.5, aVertexPosition.y * 0.5 + 0.5);
        gl_Position = vec4(aVertexPosition, 1.0);
    }`,_=`
    precision mediump float;
    varying vec2 vTextureCoord;
    uniform sampler2D uColor;
    uniform sampler2D uDepth;
    uniform int uSize;
    uniform int uDepthEnable;

    $chunkfct

    void main(void)
    {
        $chunkcall
        gl_FragColor = color;
    }`;class I extends l.a{constructor({minDepth:R=0.1,maxDepth:D=0.2,samples:P=5,xBlur:F=!0,power:A=1,depthCurve:U=100}){super(null,'aVertexPosition','uColor'),this.power=A,this.xBlur=F,this.depthCurve=U,this.useColorTexture('uColor'),this.useDepthTexture('uDepth','uDepthEnable');const L=this._initFragmentShader(R,D,P);this.program=new m.a(E,L),F?this.useUWidth('uSize',1):this.useUHeight('uSize',1)}_initFragmentShader(R=0.1,D=0.3,P=5){const F=this.xBlur,A=u(this.power),U=[];for(let M=0;M<P;M++){const N=this._getKernels(M+1);U.push(N)}let L='';for(let M=0;M<U.length;M++){const N=U[M];L+=`
            vec4 blur${M+1}(sampler2D i, vec2 uv) {
                vec2 m;
                vec4 color = texture2D(i, uv) * ${u(N[0])};`;for(let O=1;O<N.length;O++)L+=`
                m = ${F?'vec2('+O+'.0 * '+A+' / float(uSize), 0.0)':'vec2(0.0, '+O+'.0 * '+A+' / float(uSize))'};
                color += texture2D(i, uv + m) * ${u(N[O])};
                color += texture2D(i, uv - m) * ${u(N[O])};`;L+='return color; }'}let C=`
            float depthValue = 0.0;
            vec4 color;
            if (uDepthEnable >= 0) {
                vec4 depth = texture2D(uDepth, vTextureCoord.xy);
                depthValue = pow(depth.x, ${u(this.depthCurve)});
                
                int blurPower = int(floor(0.5 + (depthValue - ${u(R)}) * ${u(P)} / ${u(D-R)}));   
        `;for(let M=0;M<P;M++){const N='blurPower'+(M>P-2?' >= '+M:1>M?' < 1':' == '+M);C+=`${0<M?' else if':'if'} ( ${N}) {
                color = blur${M+1}(uColor, vTextureCoord.xy);
            }`}C+=`
        } else {
            color = texture2D(uColor, vTextureCoord.xy);
        }
        `;const B=_.replace('$chunkfct',L).replace('$chunkcall',C);return B}_getKernels(R){const D=[];let P=0;for(let F=1;F<R+2;F++){const A=3*(F-1)/R,U=Math.exp(-A*A);P+=2>F?U:U+U,D.push(U)}for(let F=0;F<D.length;F++)D[F]/=P;return D}}d.a=I},function(n,d){'use strict';d.a=class{constructor(l){this.label=l}isInitialized(){return!0}init(){return!0}setTexture(l){this.pointer=l.pointer,this.target=l.target}draw(l,m,T){l.uniform1i(m,T),l.activeTexture(l.TEXTURE0+T),l.bindTexture(this.target,this.pointer)}}},function(n,d,o){'use strict';function u(){X.matrix.rotate(5e-3,[0,1,0]),J.matrix.rotate(-5e-3,[0,1,0]),$.matrix.rotate(0.01,[0,1,0]),oe.matrix.rotate(-0.01,[0,1,0]),le.matrix.rotate(0.025,[0.72,-0.33,0.5]),fe.draw(),requestAnimationFrame(u)}Object.defineProperty(d,'__esModule',{value:!0});var l=o(0),m=o(13),T=o(4),E=o(2),_=o(5),I=o(12),R=o(6),D=o(10),P=o(11),F=o(1),A=o(14),U=o(16),L=o(15);const C=document.body.querySelector('canvas'),B=new D.a('uPMatrix'),M=new P.a(C,B);M.bgColor=[0,0,0.1,1],M.depthTest=!0;const N=new E.a,O=`
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec4 vColor;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        float zDepth = 0.2 * (8.0 - gl_Position.z);
        vec4 modifyColor = vec4(aVertexColor.rgb * zDepth, aVertexColor.a);
        vColor = modifyColor;
    }
`,v=new E.a(O),W=new _.a;W.addVertices('aVertexPosition',[0,1,0,-1,-1,1,1,-1,1,0,1,0,1,-1,1,1,-1,-1,0,1,0,1,-1,-1,-1,-1,-1,0,1,0,-1,-1,-1,-1,-1,1],3),W.addVertices('aVertexColor',[1,0,0,1,0,1,0,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,0,1],4);const X=new R.a(W,N),G=new m.a('uMVMatrix');X.addUniform(G),X.matrix=G.data,X.matrix.translate([-1.5,-1.5,-8]),M.addMesh(X);const q=[-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1],Z=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23],k=[[1,0,0,1],[1,1,0,1],[0,1,0,1],[1,0.5,0.5,1],[1,0,1,1],[0,0,1,1]];let K=[];for(let ge in k)for(let xe=0;4>xe;xe++)K=K.concat(k[ge]);const Y=new _.a;Y.addVertices('aVertexPosition',q,3),Y.addVertices('aVertexColor',K,4),Y.addIndices(Z);const $=new R.a(Y,v),Q=new m.a('uMVMatrix');$.addUniform(Q),$.matrix=Q.data,$.matrix.translate([1.5,-1.5,-8]),M.addMesh($);const J=new R.a(W,N),ee=new m.a('uMVMatrix');J.addUniform(ee),J.matrix=ee.data,J.matrix.translate([-1.5,1.5,-8]),J.matrix.scale([1,-1,1]),M.addMesh(J);const te=`   
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec2 vTextureCoord;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
    }`,re=`
    precision mediump float;

    varying vec2 vTextureCoord;

    uniform sampler2D uDiffuse1;
    uniform sampler2D uDiffuse2;

    void main(void) {
        vec4 color1 = texture2D(uDiffuse1, vec2(vTextureCoord.s, vTextureCoord.t));
        vec4 color2 = texture2D(uDiffuse2, vec2(vTextureCoord.s, vTextureCoord.t));
        float power = ((sin(vTextureCoord.s * 3.1415)) * (sin(vTextureCoord.t * 3.1415)));
        gl_FragColor = mix(color1, color2, power);
    }`,ae=new E.a(te,re);const se=new I.a('uDiffuse1');se.addURL('cube-diffuse.jpg');const ne=new I.a('uDiffuse2');ne.setParam(10240,9728),ne.setParam(10241,9728),ne.addURL('cube-diffuse-2.png');const de=new _.a;de.addVertices('aVertexPosition',q,3),de.addVertices('aTextureCoord',[0,0,1,0,1,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,0,1,1,0,1,0,0,0,0,1,0,1,1,0,1],2),de.addIndices(Z);const oe=new R.a(de,ae),ue=new m.a('uMVMatrix');oe.addUniform(ue),oe.matrix=ue.data,oe.addTexture(se),oe.addTexture(ne),oe.matrix.translate([1.5,1.5,-8]),M.addMesh(oe);const le=new R.a(de,ae),pe=new m.a('uMVMatrix');le.addUniform(pe),le.matrix=pe.data,le.addTexture(se),le.addTexture(ne),le.matrix.translate([0,0,-15]),M.addMesh(le),M.sort();const me=!0;let fe;{fe=new A.a(M);const ge=new L.a({minDepth:0.5,maxDepth:0.6,minPower:0,maxPower:1,depthCurve:100,color:[0.9,0.95,1]});fe.addPass(ge);const xe={minDepth:0.52,maxDepth:0.7,samples:20,xBlur:!0,power:1,depthCurve:50},Te=new U.a(xe);fe.addPass(Te),xe.xBlur=!1;const ce=new U.a(xe);fe.addPass(ce)}const he=()=>{const ge=[window.innerWidth,window.innerHeight],xe=1;fe.resize(ge[0]*xe,ge[1]*xe),C.width=ge[0]*xe,C.height=ge[1]*xe,C.style.width='100%',C.style.height='100%',B.update(...ge)};window.onresize=he,he(),window.scene=M,window.passManager=fe,u()},function(n,d){'use strict';d.a=class{constructor(){this.pointer=null}isInitialized(){return!!this.pointer}init(l){const m=l.createFramebuffer();return l.bindFramebuffer(l.FRAMEBUFFER,m),this.pointer=m,!0}bind(l){l.bindFramebuffer(l.FRAMEBUFFER,this.pointer)}free(l){l.bindFramebuffer(l.FRAMEBUFFER,null)}}},function(n,d){'use strict';d.a=class{constructor(l,m){this.pointer=null,this.width=l,this.height=m}resize(l,m){this.width=l,this.height=m,this.updated=!0}isInitialized(){return!!this.pointer}init(l){const m=l.createRenderbuffer();l.bindRenderbuffer(l.RENDERBUFFER,m),l.renderbufferStorage(l.RENDERBUFFER,l.DEPTH_COMPONENT16,this.width,this.height),this.pointer=m}bind(l){l.bindRenderbuffer(l.RENDERBUFFER,renderBuffer),this.updated&&(l.renderbufferStorage(l.RENDERBUFFER,l.DEPTH_COMPONENT16,this.width,this.height),this.updated=!1)}}},function(n,d,o){'use strict';var u=o(8),l=o(20),m=o(19);class T{constructor(E,_,I=!0,R=!1){this.captureDepth=I,this.recordDepth=R,this.width=E,this.height=_,this.updated=!1,this._pingpong=!1,this._colorTextures=[this._genColorTexture('frameBufferColor0',E,_),this._genColorTexture('frameBufferColor1',E,_)],this.frameBuffer=new m.a}_genDepthTexture(E,_,I){const R=new u.a;return R.mipmap=!1,R.setInternalFormat(6402),R.setFormat(6402),R.setType(5123),R.setParam(10242,33071),R.setParam(10243,33071),R.setParam(10241,9728),R.setParam(10240,9728),R.setImg(null,_,I),R}_genColorTexture(E,_,I){const R=new u.a(E);return R.mipmap=!1,!1,R.setImg(null,_,I),R}pingpong(){this._pingpong=!this._pingpong}get colorTexture(){return this._colorTextures[this._pingpong?1:0]}resize(E,_){this.width=E,this.height=_,this.updated=!0}isInitialized(){return!!this.frameBuffer.pointer}static SET_DATA(E){T.WEBGL_depth_texture=E.getExtension('WEBGL_depth_texture')||E.getExtension('WEBKIT_WEBGL_depth_texture')||E.getExtension('MOZ_WEBGL_depth_texture'),T._DATA_INITIALIZED=!0}init(E){return T._DATA_INITIALIZED||T.SET_DATA(E),this.recordDepth&&(T.WEBGL_depth_texture?(this.depthTexture=this._genDepthTexture('frameBufferDepth',this.width,this.height),this.depthTexture.init(E)):(console.warn('WEBGL_depth_texture Extension not available!'),this.recordDepth=!1)),this.captureDepth&&(this.renderBuffer=new l.a(this.width,this.height),this.renderBuffer.init(E)),this.frameBuffer.init(E),this.pingpong(),this.colorTexture.init(E),this.pingpong(),this.colorTexture.init(E),this.depthTexture?E.framebufferTexture2D(E.FRAMEBUFFER,E.DEPTH_ATTACHMENT,E.TEXTURE_2D,this.depthTexture.pointer,0):this.renderBuffer&&E.framebufferRenderbuffer(E.FRAMEBUFFER,E.DEPTH_ATTACHMENT,E.RENDERBUFFER,this.renderBuffer.pointer),E.bindTexture(E.TEXTURE_2D,null),E.bindFramebuffer(E.FRAMEBUFFER,null),E.bindRenderbuffer(E.RENDERBUFFER,null),!0}_update(E){const _=this.width,I=this.height;this.pingpong(),this.colorTexture.resize(_,I,E),this.pingpong(),this.colorTexture.resize(_,I,E),this.depthTexture&&this.depthTexture.resize(_,I,E),this.renderBuffer&&this.renderBuffer.resize(_,I,E),this.updated=!1}start(E,_=!0){this.updated&&this._update(E),this.frameBuffer.bind(E),E.framebufferTexture2D(E.FRAMEBUFFER,E.COLOR_ATTACHMENT0,E.TEXTURE_2D,this.colorTexture.pointer,0),this.depthTexture?E.framebufferTexture2D(E.FRAMEBUFFER,E.DEPTH_ATTACHMENT,E.TEXTURE_2D,_?this.depthTexture.pointer:null,0):this.renderBuffer&&E.framebufferRenderbuffer(E.FRAMEBUFFER,E.DEPTH_ATTACHMENT,E.RENDERBUFFER,_?this.renderBuffer.pointer:null)}stop(E){this.frameBuffer.free(E)}}d.a=T}]);